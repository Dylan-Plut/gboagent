import os
import re
import time
import traceback
import pandas as pd
import snowflake.connector
import matplotlib
import matplotlib.pyplot as plt
from dotenv import load_dotenv
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.backends import default_backend
import cortex_chat

matplotlib.use('Agg')
load_dotenv(override=True)

# --- CONFIGURATION ---
ACCOUNT, HOST, USER, DATABASE, SCHEMA, ROLE, WAREHOUSE = (os.getenv(k) for k in ["ACCOUNT", "HOST", "USER", "DATABASE", "SCHEMA", "ROLE", "WAREHOUSE"])
SLACK_APP_TOKEN, SLACK_BOT_TOKEN = os.getenv("SLACK_APP_TOKEN"), os.getenv("SLACK_BOT_TOKEN")
AGENT_ENDPOINT, SEMANTIC_MODEL, RSA_PRIVATE_KEY_PATH, RSA_PRIVATE_KEY_PASSWORD, MODEL = (os.getenv(k) for k in ["AGENT_ENDPOINT", "SEMANTIC_MODEL", "RSA_PRIVATE_KEY_PATH", "RSA_PRIVATE_KEY_PASSWORD", "MODEL"])

app = App(token=SLACK_BOT_TOKEN)

@app.event("message")
def handle_message_events(body, say, client):
    if 'bot_id' in body['event']: return
    user_id, channel_id, prompt = body['event']['user'], body['event']['channel'], body['event']['text']
    try:
        client.chat_postEphemeral(channel=channel_id, user=user_id, text=":snowflake: Thinking...")
        response = CORTEX_APP.chat(prompt, CONN)
        display_agent_response(channel_id, response, say)
    except Exception as e:
        tb = traceback.extract_tb(e.__traceback__)
        last_call = tb[-1]
        error_info = f"{type(e).__name__} in {os.path.basename(last_call.filename)} at line {last_call.lineno}: {e}"
        print(f"--- FATAL ERROR: {error_info} ---")
        say(channel=channel_id, text="A critical error occurred. Please check the logs.")

def display_agent_response(channel_id, content, say):
    """Formats and sends the agent's response, handling success, partial success, and error cases."""
    if not content:
        say(channel=channel_id, text="I'm sorry, I couldn't generate a response.")
        return

    blocks = []
    fallback_text = "Here is your response."

    if content.get('error'):
        fallback_text = "An error occurred."
        blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f":x: *I encountered an error.*"}})
        if content.get('sql'):
            blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Attempted SQL:*\n```{content['sql']}```"}})
        blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Error Details:*\n`{content['error']}`"}})
    else:
        if content.get('text'):
            fallback_text = content['text']
            blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Answer:*\n{content['text']}"}})
        
        df = content.get('dataframe')
        if df is not None and not df.empty:
            # --- START: DEFINITIVE FIX FOR SLACK CHARACTER LIMIT ---
            df_string = df.to_string()
            # Slack's limit is 3001 characters. We check against a safe margin.
            if len(df_string) < 2800:
                blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Data:*\n```{df_string}```"}})
            else:
                # If the data is too long, upload it as a file instead.
                file_path = f'data_{int(time.time())}.csv'
                df.to_csv(file_path, index=False)
                app.client.files_upload_v2(
                    channel=channel_id,
                    file=file_path,
                    title="Requested Data",
                    initial_comment="The requested data was too large to display in a message, so I've attached it as a CSV file."
                )
                os.remove(file_path)
            # --- END: DEFINITIVE FIX ---

            if len(df.columns) > 1:
                chart_file = plot_chart(df)
                if chart_file:
                    app.client.files_upload_v2(channel=channel_id, file=chart_file, title="Data Chart", initial_comment="Here is a visual representation:")
                    os.remove(chart_file)
        
        blocks.extend([
            {"type": "context", "elements": [{"type": "mrkdwn", "text": "This content was generated by an AI assistant. Please review carefully."}]},
            {"type": "actions", "elements": [{"type": "button", "text": {"type": "plain_text", "text": "üëç"}, "action_id": "feedback_helpful"}, {"type": "button", "text": {"type": "plain_text", "text": "üëé"}, "action_id": "feedback_not_helpful"}]}
        ])
    
    # Only send the blocks if there are any to send (prevents errors with file-only responses)
    if blocks:
        say(channel=channel_id, text=fallback_text, blocks=blocks)

def plot_chart(df: pd.DataFrame) -> str | None:
    try:
        plt.figure(figsize=(10, 6))
        # Use a slice to handle potentially large data for charting
        plot_df = df.head(15)
        plt.pie(plot_df.iloc[:, 1], labels=plot_df.iloc[:, 0], autopct='%1.1f%%', startangle=90)
        plt.axis('equal'); plt.tight_layout()
        file_path = f'chart_{int(time.time())}.png'
        plt.savefig(file_path, format='png'); plt.close()
        return file_path
    except Exception as e:
        print(f"--- ERROR creating chart: {e} ---")
        return None

def init():
    print("Initializing application...")
    with open(RSA_PRIVATE_KEY_PATH, "rb") as pem_in:
        private_key_obj = load_pem_private_key(pem_in.read(), password=RSA_PRIVATE_KEY_PASSWORD.encode(), backend=default_backend())
    conn = snowflake.connector.connect(user=USER, account=ACCOUNT, private_key=private_key_obj, warehouse=WAREHOUSE, role=ROLE, host=HOST, database=DATABASE, schema=SCHEMA)
    print("Snowflake connection successful.")
    tools_config = [{"tool_spec": {"type": "cortex_analyst_text_to_sql", "name": "semantic_model_tool"}}]
    tool_resources_config = {"semantic_model_tool": {"semantic_model_file": SEMANTIC_MODEL}}
    cortex_app = cortex_chat.CortexChat(agent_url=AGENT_ENDPOINT, model=MODEL, account=ACCOUNT, user=USER, private_key_path=RSA_PRIVATE_KEY_PATH, private_key_password=RSA_PRIVATE_KEY_PASSWORD, tools=tools_config, tool_resources=tool_resources_config)
    print("CortexChat client initialized.")
    return conn, cortex_app

@app.event("app_home_opened")
def update_home_tab(client, event, logger):
    try:
        client.views_publish(user_id=event["user"], view={"type": "home", "blocks": [{"type": "header", "text": {"type": "plain_text", "text": "Welcome! ‚ùÑÔ∏è"}}, {"type": "section", "text": {"type": "mrkdwn", "text": "You can ask me questions about our data directly in our 1-on-1 chat."}}, {"type": "section", "text": {"type": "mrkdwn", "text": "*Examples:*\n‚Ä¢ `What are the top 10 movie theatres this week?`\n‚Ä¢ `Show me a breakdown of customer support tickets by service type.`"}}]} )
    except Exception as e: logger.error(f"Error publishing App Home: {e}")

@app.action(re.compile("feedback_(helpful|not_helpful)"))
def handle_feedback(ack, body, say):
    ack()
    say(text="Thank you for your feedback!", channel=body['channel']['id'])

if __name__ == "__main__":
    CONN, CORTEX_APP = init()
    handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    print("Bolt app is running!")
    handler.start()