# Standard library imports
import os
import re
import time
import traceback
import pandas as pd
import snowflake.connector
import matplotlib
import matplotlib.pyplot as plt
from dotenv import load_dotenv
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.backends import default_backend
# Import custom module for Cortex Chat functionality
import cortex_chat

# Set matplotlib backend to non-GUI mode for server environments
matplotlib.use('Agg')
# Load environment variables
load_dotenv(override=True)

# --- CONFIGURATION ---
# Extract configuration from environment variables
ACCOUNT, HOST, USER, DATABASE, SCHEMA, ROLE, WAREHOUSE = (os.getenv(k) for k in ["ACCOUNT", "HOST", "USER", "DATABASE", "SCHEMA", "ROLE", "WAREHOUSE"])
SLACK_APP_TOKEN, SLACK_BOT_TOKEN = os.getenv("SLACK_APP_TOKEN"), os.getenv("SLACK_BOT_TOKEN")
AGENT_ENDPOINT, SEMANTIC_MODEL, RSA_PRIVATE_KEY_PATH, RSA_PRIVATE_KEY_PASSWORD, MODEL = (os.getenv(k) for k in ["AGENT_ENDPOINT", "SEMANTIC_MODEL", "RSA_PRIVATE_KEY_PATH", "RSA_PRIVATE_KEY_PASSWORD", "MODEL"])

# Initialize the Slack app
app = App(token=SLACK_BOT_TOKEN)

@app.event("message")
def handle_message_events(body, say, client):
    """
    Processes incoming Slack messages and generates responses using Cortex agent.
    Handles special cases, formats responses, and displays data visualizations.
    """
    # Ignore messages from bots to prevent infinite loops
    if 'bot_id' in body['event']: return
    
    # Extract key information from the message event
    user_id, channel_id, prompt = body['event']['user'], body['event']['channel'], body['event']['text']
    
    # Special case handling for a specific question
    if prompt.lower() == "whoose your daddy":
        say(channel=channel_id, text="Dylan Plut")
        return
        
    try:
        # Post initial "thinking" message and get its timestamp for future updates
        initial_response = client.chat_postMessage(
            channel=channel_id, 
            text=":snowflake: Thinking...",
            blocks=[{
                "type": "section", 
                "text": {"type": "mrkdwn", "text": ":snowflake: *Processing your request...*"}
            }]
        )
        message_ts = initial_response['ts']
        
        # Define callback function to update the message as processing happens
        def update_message_callback(text=None, is_final=False, df=None, sql=None, error=None):
            """
            Updates the Slack message with progress, results, or errors.
            Handles file uploads for large datasets and charts.
            """
            blocks = []
            
            if error:
                # Error handling - show error details and SQL if available
                blocks = [
                    {"type": "section", "text": {"type": "mrkdwn", "text": f":x: *I encountered an error.*"}},
                ]
                if sql:
                    blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Attempted SQL:*\n```{sql}```"}})
                blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Error Details:*\n`{error}`"}})
            else:
                # Normal response flow
                if text:
                    message_text = "*Answer:*\n" + text
                    blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": message_text}})
                
                if is_final:
                    # For final updates, include data if available
                    if df is not None and not df.empty:
                        # Handle dataframe rendering
                        df_string = df.to_string()
                        if len(df_string) < 2800:
                            # Display data directly if it's small enough
                            blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"*Data:*\n```{df_string}```"}})
                        else:
                            # For large datasets, prepare as a file
                            blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": "*Data is being prepared as a file (too large to display directly)*"}})
                    
                    # Add attribution and feedback buttons on final message
                    blocks.extend([
                        {"type": "context", "elements": [{"type": "mrkdwn", "text": "This content was generated by an AI assistant. Please review carefully."}]},
                        {"type": "actions", "elements": [
                            {"type": "button", "text": {"type": "plain_text", "text": "👍"}, "action_id": "feedback_helpful"}, 
                            {"type": "button", "text": {"type": "plain_text", "text": "👎"}, "action_id": "feedback_not_helpful"}
                        ]}
                    ])
            
            # Update the message
            client.chat_update(
                channel=channel_id,
                ts=message_ts,
                text=text if text else "Processing your request...",
                blocks=blocks
            )
            
            # For final update with large data, handle file uploads separately
            if is_final and df is not None and not df.empty and len(df.to_string()) >= 2800:
                file_path = f'data_{int(time.time())}.csv'
                df.to_csv(file_path, index=False)
                client.files_upload_v2(
                    channel=channel_id,
                    file=file_path,
                    title="Requested Data",
                    initial_comment="Here is the complete data set:"
                )
                os.remove(file_path)
                
                # Generate chart if possible
                if len(df.columns) > 1:
                    chart_file = plot_chart(df)
                    if chart_file:
                        client.files_upload_v2(
                            channel=channel_id, 
                            file=chart_file, 
                            title="Data Chart", 
                            initial_comment="Here is a visual representation:"
                        )
                        os.remove(chart_file)
        
        # Call the chat method with the callback
        CORTEX_APP.chat(prompt, CONN, update_message_callback)
        
    except Exception as e:
        # Detailed error handling with traceback information
        tb = traceback.extract_tb(e.__traceback__)
        last_call = tb[-1]
        error_info = f"{type(e).__name__} in {os.path.basename(last_call.filename)} at line {last_call.lineno}: {e}"
        print(f"--- FATAL ERROR: {error_info} ---")
        try:
            client.chat_update(
                channel=channel_id,
                ts=message_ts,
                text="A critical error occurred. Please check the logs.",
                blocks=[{"type": "section", "text": {"type": "mrkdwn", "text": ":warning: *A critical error occurred. Please check the logs.*"}}]
            )
        except:
            say(channel=channel_id, text="A critical error occurred. Please check the logs.")

def plot_chart(df: pd.DataFrame) -> str | None:
    """
    Creates a visualization from a dataframe based on its structure.
    Chooses appropriate chart type (bar chart, scatter plot, pie chart) based on data.
    Returns the path to the generated chart file or None if chart creation failed.
    """
    try:
        plt.figure(figsize=(10, 6))
        # Use a slice to handle potentially large data for charting
        plot_df = df.head(15)
        
        # Check column types and determine appropriate chart
        numeric_cols = plot_df.select_dtypes(include=['number']).columns.tolist()
        
        # If we don't have at least one numeric column, we can't chart
        if not numeric_cols:
            print("--- No numeric columns available for charting ---")
            return None
        
        # Detect date columns or string columns that might contain dates
        potential_date_cols = []
        for col in plot_df.columns:
            if col not in numeric_cols:
                # Check if column contains date-like strings
                if any(re.search(r'\d+[/-]\d+|\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\b', str(x)) 
                       for x in plot_df[col].dropna().head(3)):
                    potential_date_cols.append(col)
        
        # Determine chart type based on data structure
        if len(df.columns) >= 2:
            if potential_date_cols and numeric_cols:
                # Time series or categorical data - use bar chart
                print(f"--- Creating bar chart with x={potential_date_cols[0]}, y={numeric_cols[0]} ---")
                x_col = potential_date_cols[0]
                y_col = numeric_cols[0]
                
                # Ensure x-axis labels will fit
                if len(plot_df) > 8:
                    plt.figure(figsize=(12, 6))
                    plt.xticks(rotation=45, ha='right')
                
                # Create the bar chart
                plt.bar(plot_df[x_col].astype(str), plot_df[y_col])
                plt.xlabel(x_col)
                plt.ylabel(y_col)
                plt.title(f"{y_col} by {x_col}")
                plt.tight_layout()
                
            elif len(numeric_cols) >= 2:
                # Multiple numeric columns - scatter plot
                print(f"--- Creating scatter plot with x={numeric_cols[0]}, y={numeric_cols[1]} ---")
                plt.scatter(plot_df[numeric_cols[0]], plot_df[numeric_cols[1]])
                plt.xlabel(numeric_cols[0])
                plt.ylabel(numeric_cols[1])
                plt.title(f"{numeric_cols[1]} vs {numeric_cols[0]}")
                
            else:
                # Single numeric column with categories - pie chart
                print(f"--- Creating pie chart ---")
                # Filter out non-numeric values in the numeric column
                valid_data = plot_df[~plot_df[numeric_cols[0]].isna()]
                if len(valid_data) < 2:
                    print("--- Not enough valid data points for a pie chart ---")
                    return None
                    
                # Use the first non-numeric column as labels if available
                label_col = next((col for col in plot_df.columns if col not in numeric_cols), None)
                
                if label_col:
                    labels = valid_data[label_col].astype(str)
                else:
                    labels = [f"Category {i+1}" for i in range(len(valid_data))]
                    
                plt.pie(valid_data[numeric_cols[0]], labels=labels, autopct='%1.1f%%', startangle=90)
                plt.axis('equal')
                
        else:
            # Single column - create a simple bar chart
            print("--- Creating simple bar chart with single column ---")
            if numeric_cols:
                plt.bar(range(len(plot_df)), plot_df[numeric_cols[0]])
                plt.title(numeric_cols[0])
            else:
                print("--- Cannot create chart without numeric data ---")
                return None
        
        # Save and return file path
        file_path = f'chart_{int(time.time())}.png'
        plt.tight_layout()
        plt.savefig(file_path, format='png')
        plt.close()
        return file_path
        
    except Exception as e:
        print(f"--- ERROR creating chart: {e} ---")
        traceback.print_exc()  # Print full stack trace for better debugging
        return None

def init():
    """
    Initializes the application by:
    1. Setting up a Snowflake connection with private key authentication
    2. Creating a CortexChat client with appropriate configuration
    Returns the connection and chat client objects
    """
    print("Initializing application...")
    with open(RSA_PRIVATE_KEY_PATH, "rb") as pem_in:
        private_key_obj = load_pem_private_key(pem_in.read(), password=RSA_PRIVATE_KEY_PASSWORD.encode(), backend=default_backend())
    conn = snowflake.connector.connect(user=USER, account=ACCOUNT, private_key=private_key_obj, warehouse=WAREHOUSE, role=ROLE, host=HOST, database=DATABASE, schema=SCHEMA)
    print("Snowflake connection successful.")
    tools_config = [{"tool_spec": {"type": "cortex_analyst_text_to_sql", "name": "semantic_model_tool"}}]
    tool_resources_config = {"semantic_model_tool": {"semantic_model_file": SEMANTIC_MODEL}}
    cortex_app = cortex_chat.CortexChat(agent_url=AGENT_ENDPOINT, model=MODEL, account=ACCOUNT, user=USER, private_key_path=RSA_PRIVATE_KEY_PATH, private_key_password=RSA_PRIVATE_KEY_PASSWORD, tools=tools_config, tool_resources=tool_resources_config)
    print("CortexChat client initialized.")
    return conn, cortex_app

@app.event("app_home_opened")
def update_home_tab(client, event, logger):
    """Updates the Slack App Home tab with welcome message and examples when opened"""
    try:
        client.views_publish(user_id=event["user"], view={"type": "home", "blocks": [{"type": "header", "text": {"type": "plain_text", "text": "Welcome! ❄️"}}, {"type": "section", "text": {"type": "mrkdwn", "text": "You can ask me questions about our data directly in our 1-on-1 chat."}}, {"type": "section", "text": {"type": "mrkdwn", "text": "*Examples:*\n• `What are the top 10 movie theatres this week?`\n• `Show me a breakdown of customer support tickets by service type.`"}}]} )
    except Exception as e: logger.error(f"Error publishing App Home: {e}")

@app.action(re.compile("feedback_(helpful|not_helpful)"))
def handle_feedback(ack, body, say):
    """Handles user feedback buttons (thumbs up/down)"""
    ack()
    say(text="Thank you for your feedback!", channel=body['channel']['id'])

if __name__ == "__main__":
    CONN, CORTEX_APP = init()
    handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    print("Bolt app is running!")
    handler.start()